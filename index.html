<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mira nas Transa√ß√µes - Arc Testnet</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div id="hud-info">
        <!-- Wallet Card -->
        <div class="hud-card wallet-card">
            <div class="card-header">
                <svg class="card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M21 12c0 1.66-1.34 3-3 3H6c-1.66 0-3-1.34-3-3s1.34-3 3-3h12c1.66 0 3 1.34 3 3z"/>
                    <path d="M3 12h18"/>
                </svg>
                <span class="card-title">WALLET</span>
            </div>
            <div class="card-content">
                <div id="wallet-info">Wallet: Not Connected</div>
            </div>
        </div>
        
        <!-- Stats Card -->
        <div class="hud-card stats-card">
            <div class="card-header">
                <svg class="card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
                </svg>
                <span class="card-title">STATS</span>
            </div>
            <div class="card-content">
                <div class="stat-row">
                    <span class="stat-label">SCORE</span>
                    <span id="score" class="stat-value">0</span>
                </div>
                <div class="stat-divider"></div>
                <div class="stat-row">
                    <span class="stat-label">PENDING KILLS</span>
                    <span id="pending-kills" class="stat-value">0</span>
                </div>
                <div id="combo-display" class="stat-row combo-row" style="display: none;">
                    <span class="stat-label">COMBO</span>
                    <span class="stat-value combo-value">0x</span>
                </div>
                <div class="stat-divider"></div>
                <div class="stat-row">
                    <span class="stat-label">LEVEL</span>
                    <span id="level-display" class="stat-value">1</span>
                </div>
                <div id="xp-bar" class="xp-bar">
                    <div id="xp-bar-fill" class="xp-bar-fill">
                        <div class="xp-bar-shine"></div>
                    </div>
                    <div class="xp-bar-particles"></div>
                </div>
            </div>
        </div>
        
        <!-- Claim Card -->
        <div class="hud-card claim-card" id="claim-button-container" style="display: none;">
            <div class="card-header claim-header">
                <svg class="card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                <span class="card-title">CLAIM</span>
            </div>
            <div class="card-content claim-content">
                <button id="claim-kills-btn" class="claim-button">
                    <span class="button-text">Claim Kills</span>
                    <span class="button-glow"></span>
                </button>
            </div>
        </div>
        
        <!-- Controls Card -->
        <div class="hud-card controls-card">
            <div class="card-header">
                <svg class="card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <path d="M9 9h6v6H9z"/>
                </svg>
                <span class="card-title">CONTROLS</span>
            </div>
            <div class="card-content controls-content">
                <button id="connect-wallet" class="control-btn">
                    <span class="btn-icon">üîó</span>
                    <span class="btn-text">Connect Wallet</span>
                </button>
                <button id="create-wallet" class="control-btn">
                    <span class="btn-icon">‚ö°</span>
                    <span class="btn-text">Create Local Wallet</span>
                </button>
                <button id="disconnect-wallet" class="control-btn" style="display: none;">
                    <span class="btn-icon">üîå</span>
                    <span class="btn-text">Disconnect</span>
                </button>
                <button id="reset-session" class="control-btn">
                    <span class="btn-icon">üîÑ</span>
                    <span class="btn-text">Reset Session</span>
                </button>
            </div>
        </div>
    </div>
    
    <div id="game"></div>
    
    <script type="module">
        import { RPC_URL } from './js/config.js';
        import { 
            loadEthers, 
            loadWallet, 
            createWallet, 
            saveWallet,
            connectExternalWallet,
            hasExternalWallet,
            saveWalletPreference,
            getWalletPreference
        } from './js/wallet.js';
        import { initGame, setWallet, setProvider, resetScore, setNotificationCallback, resetGameAfterClaim, setPendingKillsUpdateCallback } from './js/game.js';
        import { initUI, updateScore, updateWalletInfo, createNotification, showClaimButton, hideClaimButton } from './js/ui.js';
        import { claimKills } from './js/blockchain.js';
        import { getPendingKills, clearKills, canClaim } from './js/killQueue.js';
        import { MIN_KILLS_FOR_CLAIM } from './js/config.js';

        let wallet = null;
        let provider = null;
        let game = null;
        let isExternalWallet = false;
        let totalPoints = 0;  // Acumula por kill

        // Inicializa UI
        initUI();
        setNotificationCallback(createNotification);
        
        // Callback para atualizar bot√£o de claim quando kills mudarem
        setPendingKillsUpdateCallback((pendingKills) => {
            if (canClaim()) {
                // Obt√©m scene do Phaser para passar para showClaimButton
                const scene = game && game.scene && game.scene.scenes && game.scene.scenes[0] ? game.scene.scenes[0] : null;
                showClaimButton(scene, pendingKills, async () => {
                    await handleClaimKills();
                });
            } else {
                hideClaimButton();
            }
        });
        
        // Conecta bot√£o HTML do HUD ao handler de claim (ser√° configurado no showClaimButton)
        
        // Fun√ß√£o para atualizar UI do bot√£o de claim (n√£o mais necess√°ria, bot√£o √© atualizado via showClaimButton)
        function updateClaimUI() {
            // Bot√£o de claim agora √© gerenciado via showClaimButton/hideClaimButton
            // N√£o precisa mais atualizar manualmente
        }
        
        // Fun√ß√£o para fazer claim de tokens
        async function claimTokens(scene) {
            if (!wallet || totalPoints <= 0) {
                createNotification(scene, 'No points to claim!', 'error');
                return;
            }
            
            try {
                const Ethers = await loadEthers();
                const { CONTRACT_ADDRESS, CONTRACT_ABI } = await import('./js/config.js');
                const contract = new Ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, wallet);
                
                // Verifica se h√° pontos suficientes antes de enviar
                console.log('Tentando fazer claim de', totalPoints, 'pontos...');
                console.log('Endere√ßo da wallet:', wallet.address);
                
                // Checa estado on-chain (view)
                const pending = await contract.getPlayerKills(wallet.address);
                console.log('Kills j√° reivindicados on-chain:', pending.toString());
                
                // Tenta estimar gas primeiro - isso vai detectar se h√° algum problema
                try {
                    const estimatedGas = await contract.claimKills.estimateGas(totalPoints);
                    console.log('Gas estimado:', estimatedGas.toString());
                } catch (estimateErr) {
                    console.error('Erro ao estimar gas:', estimateErr);
                    
                    // Verifica se √© erro de cap di√°rio
                    if (estimateErr.reason && estimateErr.reason.includes('Daily cap')) {
                        createNotification(scene, 'Cap di√°rio j√° foi reivindicado! Tente novamente amanh√£.', 'error');
                        return;
                    }
                    
                    // Outros erros
                    const errorMsg = estimateErr.reason || estimateErr.message || 'Erro desconhecido';
                    createNotification(scene, `Erro: ${errorMsg}`, 'error');
                    return;
                }
                
                const tx = await contract.claimKills(totalPoints, { gasLimit: 150000 });
                console.log('Claim TX:', tx.hash);
                
                const receipt = await tx.wait();
                
                // Verifica se a transa√ß√£o foi bem-sucedida
                if (receipt.status === 0) {
                    console.error('Transa√ß√£o revertida! Receipt:', receipt);
                    createNotification(scene, 'Transa√ß√£o revertida. Verifique o contrato.', 'error');
                    return;
                }
                
                console.log('Claim Confirmada! Tokens minted: ~' + totalPoints);
                
                const txUrl = `https://testnet.arcscan.app/tx/${tx.hash}`;
                createNotification(scene, `Claimed ${totalPoints} pts ‚Üí ${totalPoints} tokens! TX: ${tx.hash.substring(0,10)}...`, 'success', {
                    hash: tx.hash,
                    url: txUrl
                });
                
                // Reset local
                totalPoints = 0;
                window.totalPoints = 0;
                updateClaimUI();
                
                // Limpa kills pendentes tamb√©m
                clearKills();
                resetGameAfterClaim();
                
                // Atualiza saldo
                if (provider) {
                    try {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const balance = await provider.getBalance(wallet.address);
                        const balanceEth = await Ethers.formatEther(balance);
                        const isLowBalance = parseFloat(balanceEth) < 0.001;
                        
                        // Busca balance do token ARCGAME
                        let tokenBalance = null;
                        try {
                            const { getTokenBalance } = await import('./js/blockchain.js');
                            tokenBalance = await getTokenBalance(provider, wallet.address);
                        } catch (tokenErr) {
                            console.error('Erro ao buscar balance do token:', tokenErr);
                        }
                        
                        updateWalletInfo(wallet.address, balanceEth, isLowBalance, isExternalWallet, isExternalWallet ? 'correct' : null, tokenBalance);
                    } catch (balanceErr) {
                        console.error('Erro ao atualizar saldo:', balanceErr);
                    }
                }
                
            } catch (err) {
                console.error('Claim Error completo:', err);
                console.error('Claim Error message:', err.message);
                console.error('Claim Error reason:', err.reason);
                console.error('Claim Error data:', err.data);
                
                // Tenta extrair mensagem de erro mais espec√≠fica
                let errorMessage = err.message || 'Erro desconhecido';
                if (err.reason) {
                    errorMessage = err.reason;
                } else if (err.data && err.data.message) {
                    errorMessage = err.data.message;
                }
                
                createNotification(scene, `Claim falhou: ${errorMessage.substring(0,50)}...`, 'error');
            }
        }
        
        // Exp√µe fun√ß√µes globalmente para acesso do Phaser
        window.totalPoints = totalPoints;
        window.updateClaimUI = updateClaimUI;
        window.claimTokens = claimTokens;
        
        // Fun√ß√£o para processar claim de kills (mantida para compatibilidade)
        async function handleClaimKills() {
            if (!wallet || !provider) {
                alert('Conecte uma wallet para fazer claim!');
                return;
            }
            
            const pendingKills = getPendingKills();
            if (pendingKills < MIN_KILLS_FOR_CLAIM) {
                alert(`Voc√™ precisa de pelo menos ${MIN_KILLS_FOR_CLAIM} kills para fazer claim!`);
                return;
            }
            
            try {
                // Obt√©m a scene do Phaser
                const scene = game.scene.scenes[0];
                
                // Chama fun√ß√£o de claim
                await claimKills(
                    scene,
                    wallet,
                    provider,
                    pendingKills,
                    (txData) => {
                        // Sucesso
                        createNotification(scene, `Claimed ${pendingKills} kills!`, 'success', txData);
                        // Limpa kills pendentes e reseta score
                        clearKills();
                        resetGameAfterClaim();
                        hideClaimButton();
                        
                        // Atualiza totalPoints
                        totalPoints = 0;
                        window.totalPoints = 0;
                        updateClaimUI();
                    },
                    (error) => {
                        // Erro
                        createNotification(scene, `Claim falhou: ${error.substring(0, 50)}...`, 'error');
                    },
                    async (address, newBalance, tokenBalance = null) => {
                        // Atualiza saldo
                        const isLowBalance = parseFloat(newBalance) < 0.001;
                        
                        // Se tokenBalance n√£o foi passado, busca
                        if (tokenBalance === null) {
                            try {
                                const { getTokenBalance } = await import('./js/blockchain.js');
                                tokenBalance = await getTokenBalance(provider, address);
                            } catch (tokenErr) {
                                console.error('Erro ao buscar balance do token:', tokenErr);
                            }
                        }
                        
                        updateWalletInfo(address, newBalance, isLowBalance, isExternalWallet, isExternalWallet ? 'correct' : null, tokenBalance);
                    }
                );
            } catch (err) {
                console.error('Erro ao fazer claim:', err);
                alert('Erro ao fazer claim: ' + err.message);
            }
        }

        // Fun√ß√£o para atualizar UI ap√≥s conectar wallet
        async function updateWalletUI(walletInstance, providerInstance, isExternal = false) {
            try {
                const balance = await providerInstance.getBalance(walletInstance.address);
                const balanceEth = await loadEthers().then(Ethers => Ethers.formatEther(balance));
                const isLowBalance = parseFloat(balanceEth) < 0.001;
                
                // Verifica status da rede se for wallet externa
                let networkStatus = null;
                if (isExternal) {
                    const { isArcTestnet } = await import('./js/wallet.js');
                    const isCorrect = await isArcTestnet();
                    networkStatus = isCorrect ? 'correct' : 'incorrect';
                }
                
                // Busca balance do token ARCGAME
                let tokenBalance = null;
                try {
                    const { getTokenBalance } = await import('./js/blockchain.js');
                    tokenBalance = await getTokenBalance(providerInstance, walletInstance.address);
                } catch (tokenErr) {
                    console.error('Erro ao buscar balance do token:', tokenErr);
                }
                
                updateWalletInfo(walletInstance.address, balanceEth, isLowBalance, isExternal, networkStatus, tokenBalance);
                
                // Atualiza bot√µes
                document.getElementById('connect-wallet').style.display = isExternal ? 'none' : 'block';
                document.getElementById('create-wallet').style.display = isExternal ? 'none' : 'block';
                document.getElementById('disconnect-wallet').style.display = isExternal ? 'block' : 'none';
                
                console.log('Wallet conectada:', walletInstance.address, 'Balance:', balanceEth, 'External:', isExternal, 'Network:', networkStatus);
                
                if (isLowBalance) {
                    alert('Fund with USDC testnet on faucet to play!');
                }
                
                if (isExternal && networkStatus === 'incorrect') {
                    alert('Voc√™ est√° conectado a uma rede diferente. Por favor, mude para Arc Testnet no MetaMask.');
                }
            } catch (err) {
                console.error('Erro ao atualizar UI:', err);
            }
        }

        // Connect Wallet Button (Wallet Externa)
        document.getElementById('connect-wallet').addEventListener('click', async () => {
            try {
                if (!hasExternalWallet()) {
                    alert('Nenhuma wallet externa detectada. Instale MetaMask ou outra wallet compat√≠vel.');
                    return;
                }
                
                const result = await connectExternalWallet();
                wallet = result.wallet;
                provider = result.provider;
                isExternalWallet = true;
                
                setWallet(wallet);
                setProvider(provider);
                saveWalletPreference(true);
                
                await updateWalletUI(wallet, provider, true);
            } catch (err) {
                console.error('Erro ao conectar wallet:', err);
                alert('Erro ao conectar wallet: ' + err.message);
            }
        });

        // Create Local Wallet Button
        document.getElementById('create-wallet').addEventListener('click', async () => {
            try {
                const Ethers = await loadEthers();
                provider = new Ethers.JsonRpcProvider(RPC_URL);
                setProvider(provider);
                
                let loadedWallet = await loadWallet();
                if (!loadedWallet) {
                    loadedWallet = await createWallet();
                    saveWallet(loadedWallet);
                }
                
                wallet = loadedWallet.connect(provider);
                isExternalWallet = false;
                
                setWallet(wallet);
                saveWalletPreference(false);
                
                await updateWalletUI(wallet, provider, false);
            } catch (err) {
                console.error('Erro ao criar wallet:', err);
                alert('Erro na wallet: ' + err.message);
            }
        });

        // Disconnect Wallet Button
        document.getElementById('disconnect-wallet').addEventListener('click', () => {
            wallet = null;
            provider = null;
            isExternalWallet = false;
            setWallet(null);
            setProvider(null);
            saveWalletPreference(false);
            
            document.getElementById('wallet-info').innerHTML = 'Wallet: Not Connected';
            document.getElementById('connect-wallet').style.display = 'block';
            document.getElementById('create-wallet').style.display = 'block';
            document.getElementById('disconnect-wallet').style.display = 'none';
        });

        // Reset Session
        document.getElementById('reset-session').addEventListener('click', () => {
            resetScore();
        });

        // Monitora mudan√ßas de rede (apenas para wallet externa)
        if (hasExternalWallet()) {
            window.ethereum.on('chainChanged', async (chainId) => {
                console.log('Rede mudou para:', chainId);
                if (isExternalWallet && wallet) {
                    // Verifica se ainda est√° na rede correta
                    const { isArcTestnet } = await import('./js/wallet.js');
                    const isCorrect = await isArcTestnet();
                    
                    if (!isCorrect) {
                        alert('Voc√™ mudou para uma rede diferente. Por favor, volte para Arc Testnet para continuar jogando.');
                        // Desconecta wallet se rede estiver incorreta
                        document.getElementById('disconnect-wallet').click();
                    } else {
                        // Reconecta se necess√°rio
                        try {
                            const result = await connectExternalWallet();
                            wallet = result.wallet;
                            provider = result.provider;
                            setWallet(wallet);
                            setProvider(provider);
                            await updateWalletUI(wallet, provider, true);
                        } catch (err) {
                            console.error('Erro ao reconectar ap√≥s mudan√ßa de rede:', err);
                        }
                    }
                }
            });

            window.ethereum.on('accountsChanged', async (accounts) => {
                console.log('Contas mudaram:', accounts);
                if (isExternalWallet && accounts.length === 0) {
                    // Usu√°rio desconectou no MetaMask
                    document.getElementById('disconnect-wallet').click();
                } else if (isExternalWallet && accounts.length > 0) {
                    // Reconecta com nova conta
                    try {
                        const result = await connectExternalWallet();
                        wallet = result.wallet;
                        provider = result.provider;
                        setWallet(wallet);
                        setProvider(provider);
                        await updateWalletUI(wallet, provider, true);
                    } catch (err) {
                        console.error('Erro ao reconectar ap√≥s mudan√ßa de conta:', err);
                    }
                }
            });
        }

        // Start Game
        window.addEventListener('load', async () => {
            try {
                await loadEthers();
                game = initGame();
                
                // Sincroniza totalPoints com kills pendentes ao iniciar
                totalPoints = getPendingKills();
                window.totalPoints = totalPoints;
                
                // Configura callback do bot√£o de claim ap√≥s game iniciar
                setTimeout(() => {
                    if (game && game.scene && game.scene.scenes && game.scene.scenes[0]) {
                        const scene = game.scene.scenes[0];
                        updateClaimUI();
                    }
                }, 1500);
                
                // N√£o cria wallet automaticamente - usu√°rio deve escolher
                // Apenas tenta reconectar wallet externa se foi a √∫ltima prefer√™ncia
                const preference = getWalletPreference();
                if (preference === 'external' && hasExternalWallet()) {
                    try {
                        const result = await connectExternalWallet();
                        wallet = result.wallet;
                        provider = result.provider;
                        isExternalWallet = true;
                        setWallet(wallet);
                        setProvider(provider);
                        await updateWalletUI(wallet, provider, true);
                    } catch (err) {
                        console.log('N√£o foi poss√≠vel reconectar wallet externa. Usu√°rio deve conectar manualmente.');
                        // N√£o faz nada - deixa usu√°rio escolher
                    }
                }
                // Se prefer√™ncia for 'local' ou n√£o houver prefer√™ncia, n√£o cria automaticamente
            } catch (err) {
                console.error('Load Error:', err);
            }
        });
    </script>
</body>
</html>
